---
title: "Specifying attribute hierarchies"
output: rmarkdown::html_vignette
bibliography: ../bib/references.bib
biblio-style: apa
csl: ../bib/apa.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{Specifying attribute hierarchies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| labels: setup
#| include: false

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

When specifying a diagnostic classification model (DCM), it is common to define relationships between the measured attributes.
For example, one attribute may be a precursor or successor to another attribute.
In other words, the attributes form a hierarchy.
In this article, we describe how to define different hierarchical relationships with dcmstan.

```{r}
#| label: load-dcmstan

library(dcmstan)
```

## Choosing a structural model

dcmstan supports two structural models that have the ability to specify an attribute hierarchy.
The hierarchical diagnostic classification model [HDCM\; @hdcm] can be defined with `hdcm()`.
The HDCM assumes a strict attribute hierarchy.
That is, possible profiles that conflict with the defined hierarchy are completely excluded from the model.
On the other hand, we can use a Bayesian Network [BayesNet\; @bayesnet] as the structural model using `bayesnet()`.
The BayesNet enforces a less restrictive hierarchy.
All possible profiles are still included in the model, but profiles that are inconsistent with the defined hierarchy are less likely.

Both `hdcm()` and `bayesnet()` include a `hierarchy` argument that can be used to define specific relationships between attributes.
In the following sections, we describe different attribute structures and show how to define these structures with dcmstan.

## Attribute structures

In general, hierarchies can be classified into two broad categories: simple and complex structures.


### Simple structures

For simple structures, attributes can exhibit a linear, converging, or diverging relationship.

```{r}
#| label: simple-structure
#| echo: false
#| message: false
#| fig-width: 8
#| fig-height: 3
#| fig-cap: Simple attribute structures

library(dagitty)
library(ggdag)
library(ggplot2)
library(dplyr)

dag_linear <- dagitty("dag { A1 -> A2 -> A3 }")
coordinates(dag_linear) <- list(
  x = c(A1 = 2, A2 = 2, A3 = 2),
  y = c(A1 = 2.6, A2 = 2, A3 = 1.4)
)

dag_converge <- dagitty("dag { A1 -> A3 <- A2 }")
coordinates(dag_converge) <- list(
  x = c(A1 = 1, A2 = 3, A3 = 2),
  y = c(A1 = 2.5, A2 = 2.5, A3 = 1.5)
)

dag_diverge <- dagitty("dag { A2 <- A1 -> A3 }")
coordinates(dag_diverge) <- list(
  x = c(A1 = 2, A2 = 1, A3 = 3),
  y = c(A1 = 2.5, A2 = 1.5, A3 = 1.5)
)

bind_rows(
  tidy_dagitty(dag_linear) |>
    mutate(type = "Linear") |>
    as_tibble(),
  tidy_dagitty(dag_converge) |>
    mutate(type = "Converging") |>
    as_tibble(),
  tidy_dagitty(dag_diverge) |>
    mutate(type = "Diverging") |>
    as_tibble()
) |>
  mutate(
    type = factor(type, levels = c("Linear", "Converging", "Diverging"))
  ) |>
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  facet_wrap(~type, nrow = 1) +
  geom_dag_node() +
  geom_dag_text(color = "white") +
  geom_dag_edges(
    edge_color = "black",
    edge_width = 2,
    arrow_directed = grid::arrow(length = grid::unit(5, "pt"), type = "closed")
  ) +
  expand_limits(x = c(0, 4), y = c(1.3, 2.7)) +
  theme_void() +
  theme(
    strip.text = element_text(
      size = 12,
      margin = margin(0, 0, 4, 0),
      face = "bold"
    ),
    plot.margin = margin(5, 0, 0, 0)
  )
```

In a linear structure, the attributes must be acquired in a specific order, one after the other.
In the figure, a respondent must be proficient on A1 before they can acquire the skills in A2, followed by A3.
We can specify this relationship in dcmstan as:

```{r}
#| label: linear
#| results: hide

hdcm(hierarchy = "A1 -> A2 -> A3")
```

We use arrows (`->`) to denote dependencies between the attributes.
In the linear example, we defined the entire hierarchy with one continuous string of attributes (i.e., `"A1 -> A2 -> A3"`).
However, we could also define each pairwise relationship separately.
For example, `"A1 -> A2 A2 -> A3"` would be an equivalent specification.
Alternatively, we can also define the hierarchy in a separate variable that is passed to the structural model function.
Consider a converging structure, where proficiency of two or more attributes is required before a culminating attribute.
All of the following specifications are equivalent.

```{r}
#| label: converge
#| results: hide

hdcm(hierarchy = "A1 -> A3 <- A2")

hdcm(hierarchy = "A1 -> A3 A2 -> A3")

converge <- "
  A1 -> A3
  A2 -> A3
"
hdcm(hierarchy = converge)
```

Finally, we can similarly define a diverging structure, where one attribute serves as a precursor to two or more attributes.
Note that although we have used `hdcm()` in these examples, the same hierarchy specifications can be provided to `bayesnet()` as well.

```{r}
#| label: diverge
#| results: hide

hdcm(hierarchy = "A2 <- A1 -> A3")

hdcm(hierarchy = "A1 -> A2 A1 -> A3")

diverge <- "
  A1 -> A2
  A1 -> A3
"
hdcm(hierarchy = diverge)
```

### Complex structures

In a complex structures, multiple simple structures are combined into a larger web of attribute relationships.
Depending on the number of attributes included on an assessment, there are an almost unlimited number of structures a hierarchy could take by mixing linear, convergent, and divergent relationships.
As an overview of how different structures can be specified in dcmstan, we'll consider a few example structures with two, three, four-levels of hierarchy.

```{r}
#| label: complex-structure
#| echo: false
#| message: false
#| fig-width: 8
#| fig-height: 3.5
#| fig-cap: Complex attribute structures

dag_complex2 <- dagitty("dag { A3 <- A1 -> A4 <- A2 -> A5 }")
coordinates(dag_complex2) <- list(
  x = c(A1 = 2, A2 = 4, A3 = 1, A4 = 3, A5 = 5),
  y = c(A1 = 2.5, A2 = 2.5, A3 = 1.5, A4 = 1.5, A5 = 1.5)
)

dag_complex3 <- dagitty(
  "dag { A1 -> A2 A1 -> A3 -> A5 A4 -> A3 }"
)
coordinates(dag_complex3) <- list(
  x = c(A1 = 2.5, A2 = 1.5, A3 = 3.5, A4 = 4.5, A5 = 3.5),
  y = c(A1 = 2.6, A2 = 2, A3 = 2, A4 = 2.6, A5 = 1.4)
)

dag_complex4 <- dagitty(
  "dag { A1 -> A2 -> A3 -> A5 A2 -> A4 -> A5 }"
)
coordinates(dag_complex4) <- list(
  x = c(A1 = 3, A2 = 3, A3 = 2, A4 = 4, A5 = 3),
  y = c(A1 = 2.7, A2 = 2.25, A3 = 1.75, A4 = 1.75, A5 = 1.3)
)

bind_rows(
  tidy_dagitty(dag_complex2) |>
    mutate(type = "Two-Level Hierarchy") |>
    as_tibble(),
  tidy_dagitty(dag_complex3) |>
    mutate(type = "Three-Level Hierarchy") |>
    as_tibble(),
  tidy_dagitty(dag_complex4) |>
    mutate(type = "Four-Level Hierarchy") |>
    as_tibble()
) |>
  mutate(
    type = factor(
      type,
      levels = c(
        "Two-Level Hierarchy",
        "Three-Level Hierarchy",
        "Four-Level Hierarchy"
      )
    )
  ) |>
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  facet_wrap(~type, nrow = 1) +
  geom_dag_node() +
  geom_dag_text(color = "white") +
  geom_dag_edges(
    edge_color = "black",
    edge_width = 2,
    arrow_directed = grid::arrow(length = grid::unit(5, "pt"), type = "closed")
  ) +
  expand_limits(x = c(0, 6), y = c(1.2, 2.8)) +
  theme_void() +
  theme(
    strip.text = element_text(
      size = 12,
      margin = margin(0, 0, 4, 0),
      face = "bold"
    ),
    plot.margin = margin(5, 0, 0, 0)
  )
```

In the two-level structure, A1 and A2 serve as precursors to two attributes each.
A3 and A4 are the culminating attributes of A1, while A4 and A5 are the culminating attributes of A2.
A4 represents a converging relationship between A1 and A2.
As with the simple structures, this relationship can be specified as one continuous chain or as a series of different relationships.
All are equivalent.

```{r}
#| label: two-level-hierarcy
#| results: hide

hdcm(hierarchy = "A3 <- A1 -> A4 <- A2 -> A5")

hdcm(hierarchy = "A1 -> A3 A2 -> A5 A1 -> A4 <- A2")

complex2 <- "
  A1 -> A3
  A1 -> A4
  A2 -> A4
  A2 -> A5
"
hdcm(hierarchy = complex2)
```

Similarly, we can define a three-level hierarchical structure that mixes linear, converging, and diverging structures.
In this configuration, A1 diverges to A2 and A3. 
A3 then is a convergence between A1 and A4.
Finally, A5 has a linear dependency on A3.
In this example, the full structure can not be written as a single chain .
Therefore, we can specify the structure in as two smaller relationships, such as `"A2 <- A1 -> A3 <- A4"` and `"A3 -> A5"`, or as a series of pairwise relationships as in the previous examples.

```{r}
#| label: three-level-hierarchy
#| results: hide

hdcm(hierarchy = "A2 <- A1 -> A3 <- A4 A3 -> A5")

complex3 <- "
  A1 -> A2
  A1 -> A3
  A4 -> A3
  A3 -> A5
"
hdcm(hierarchy = complex3)
```

Finally consider a four-level hierarchy that also mixes all three simple structures, but in different configurations.
In this example, A1 is a linear precursor to A2.
A2 then diverges into A3 and A4, which both then converge back on A5.
This structure again can be defined in a single chain, multiple smaller relationships, or pairwise relationships equivalently.

```{r}
#| label: four-level-hierarchy
#| results: hide

hdcm(hierarchy = "A1 -> A2 -> A3 -> A5 <- A4 <- A2")

hdcm(hierarchy = "A1 -> A2 -> A3 -> A5 A2 -> A4 -> A5")

complex4 <- "
  A1 -> A2
  A2 -> A3
  A2 -> A4
  A3 -> A5
  A4 -> A5
"
hdcm(hierarchy = complex4)
```

## Disallowed structures

So far, we have discussed how different attribute structures can be specified within dcmstan.
However, there are some structures that are not allowed.
Namely, a structure must be a directed acyclic graph [DAG\; @almond2015], meaning that if we follow the directions of the arrows, we must not be able to form a closed loop and return to an attribute we have already visited.

```{r}
#| label: cyclic-structure
#| echo: false
#| message: false
#| fig-width: 8
#| fig-height: 3
#| fig-cap: Invalid attribute structures

dag_cyclic1 <- dagitty("dag { A1 -> A2 -> A3 -> A1 }")
coordinates(dag_cyclic1) <- list(
  x = c(A1 = 3, A2 = 2, A3 = 4),
  y = c(A1 = 2.5, A2 = 1.5, A3 = 1.5)
)

dag_cyclic2 <- dagitty("dag { A1 -> A5 -> A2 -> A3 -> A4 A2 -> A4 A4 -> A1 }")
coordinates(dag_cyclic2) <- list(
  x = c(A1 = 3, A2 = 3, A3 = 3, A4 = 5, A5 = 1),
  y = c(A1 = 2.6, A2 = 2, A3 = 1.4, A4 = 2, A5 = 2)
)

bind_rows(
  tidy_dagitty(dag_cyclic1) |>
    mutate(type = "Example 1") |>
    as_tibble(),
  tidy_dagitty(dag_cyclic2) |>
    mutate(type = "Example 2") |>
    as_tibble()
) |>
  mutate(
    type = factor(
      type,
      levels = c(
        "Example 1",
        "Example 2"
      )
    )
  ) |>
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
  facet_wrap(~type, nrow = 1) +
  geom_dag_node() +
  geom_dag_text(color = "white") +
  geom_dag_edges(
    edge_color = "black",
    edge_width = 2,
    arrow_directed = grid::arrow(length = grid::unit(5, "pt"), type = "closed")
  ) +
  expand_limits(x = c(0, 6), y = c(1.3, 2.7)) +
  theme_void() +
  theme(
    strip.text = element_text(
      size = 12,
      margin = margin(0, 0, 4, 0),
      face = "bold"
    ),
    plot.margin = margin(5, 0, 0, 0)
  )
```

In the first example, we can start at A1 and return to A1 by following the path `A1 -> A2 -> A3 -> A1`.
Similarly in the second example, there are multiple closed loops.
For example, we can create a loop from `A1 -> A5 -> A2 -> A4 -> A1` or `A3 -> A4 -> A1 -> A5 -> A2 -> A3`.
Thus, both of these structures would be invalid.
If you specify and invalid attribute structure, you will be met with an error.

```{r}
#| label: bad-structure
#| error: true

hdcm(hierarchy = "A1 -> A2 -> A3 -> A1")

attribute_structure <- "
  A4 -> A1 -> A5 -> A2
  A3 <- A2 -> A4 <- A3
"
hdcm(hierarchy = attribute_structure)
```

## References
